<h1>Mealy's and Moore's machines and work with them</h1>
<h2>Task 1: ✅</h2>     
<ol>
    <li>Реалізувати клас MealyMachine для симуляції роботи довільного автомата Мілі, який повинен:
        <ol>
            <li>Опрацьовувати вхідний рядок та видавати вихідний рядок.</li>
            <li>Відображати таблицю переходів під час обробки.</li>
            <li>Підтримувати гнучку зміну конфігурації (вхідний алфавіт, стани, функція переходів).</li>
        </ol>
    </li>
    <li>Налаштувати та протестувати автомат Мілі для наступного сценарію:
        <ul>
            <li>Вхідний алфавіт: {a, b}</li>
            <li>Стани: {S0, S1}</li>
            <li>Функція переходів:
                <ul>
                    <li>S0 → S1 при a (вихід 0)</li>
                    <li>S0 → S0 при b (вихід 0)</li>
                    <li>S1 → S1 при a (вихід 0)</li>
                    <li>S1 → S0 при b (вихід 1)</li>
                </ul>
            </li>
            <li>Початковий стан: S0</li>
        </ul>
    </li>
    <li>Реалізувати можливість збереження стану у форматі JSON та повторного запуску автомата.     
        <pre>
Mealy.json:
{
    "current_state": "S0",
    "history": [
        ["S0", "a", "0"],
        ["S1", "a", "0"],
        ["S1", "b", "1"],
        ["S0", "b", "0"]
    ]
}
        </pre>
    </li>
</ol>
<h2>Task 2: ✅</h2>           
  Написати програму, що приймає на вхід автомат Мура та переводить його в еквівалентний
  автомат Мілі. Протестувати на власних прикладах.
<h4>Subject: Methods of projecting algorythms</h4>
<h4>University: National University of "Kyiv-Mohyla Academy"</h4>

<h1>Find all sums <i>S</i> in list <i>arr</i></h1>
<h2>Main task: ✅</h2>
<ul>
    <li>
        Function takes list of numbers and sum as input and returns all sums, that are present in list       
    </li>
    <li>
        Function must be written in a recursive way          
    </li>
</ul>
<h2>Side tasks</h2>
<ul>
    <li>
        Write docstring for the function
    </li>
    <li>
        Write unit tests for the function
    </li>
    <li>
        Calculate time-complexity of the algorythm using big O-notation
    </li>
</ul>

<h1>Maximum subarray</h1>
<h4>Link: <a href="https://leetcode.com/problems/maximum-subarray/solutions/6592899/on-solution-for-max-sum-in-subarray-by-m-ig46/">my solution</a></h4>

<h1>Завдання: Код Гафмана і Камінчики</h1>

<h2>1. Код Гафмана</h2>

<p><strong>Умова:</strong><br>Реалізувати програмно алгоритм отримання коду Гафмана.</p>
<p><strong>Вхідні дані:</strong><br>
Користувач вводить з клавіатури рядок символів. Рядок може містити будь-які символи (включно з пробілами). Довжина рядка — не більше 100 000 символів.</p>

<p><strong>Вихідні дані:</strong><br>
Для кожного унікального символу, що зустрічається у вхідному рядку, необхідно вивести відповідний Гафман-код у такому форматі:</p>
<pre><code>"символ": код</code></pre>

<p>Кожен результат виводиться з нового рядка. Порядок виводу символів — довільний.<br>
Якщо у рядку лише один унікальний символ, йому призначається код <code>"0"</code>.</p>
<p><strong>Приклад виходу:</strong></p>
<pre><code>
    "p": 111
    "r": 01
    "o": 110
    "g": 101
    "a": 100
    "m": 00
</code></pre>

<h2>2. Камінчики</h2>

<p><strong>Умова:</strong><br>
Є <code>n</code> купок з камінцями, де <code>n</code> — парне число. Кожна купка містить певну кількість камінців <code>a_i</code>. За одну операцію можна або додати 1 камінець до будь-якої купки, або            прибрати 1 камінець (якщо в купці щонайменше 1 камінець).</p>

<p><strong>Завдання:</strong><br>
    За мінімальну кількість операцій зробити так, щоб рівно половина купок містила кількість камінців, яка є повним квадратом (тобто 1, 4, 9, 16, ...), а інша половина — не була повним квадратом.</p>
    <p><strong>Вхідні дані:</strong></p>
<ul>
    <li>Перший рядок містить одне парне натуральне число <code>n</code> (2 ≤ n ≤ 200000).</li>
    <li>Другий рядок містить <code>n</code> натуральних чисел <code>a_1, a_2, ..., a_n</code> (1 ≤ a_i ≤ 10⁹), розділених пробілами.</li>
</ul>

<p><strong>Вихідні дані:</strong><br>
Одне число — мінімальна кількість операцій (додавань або віднімань), які необхідно виконати для досягнення цільової конфігурації.</p>

<p><strong>Приклад:</strong></p>
<pre><code>Вхідні дані:
4
3 5 4 10

Вихідні дані:
1</code></pre>

<p><strong>Пояснення:</strong></p>
<p>Мета — щоб у 2 купках були повні квадрати, а в інших 2 — не повні:</p>
<ul>
    <li>4 — це вже квадрат → залишаємо</li>
    <li>10 → 9 → квадрат</li>
    <li>3 і 5 — не квадрати → залишаємо</li>
</ul>

<p>Таким чином:<br>
Квадрати: 4, 9<br>
Не квадрати: 3, 5<br>
Кількість ходів: 1 (змінити 10 на 9)</p>
